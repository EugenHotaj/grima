Database schema:
All chat data is stored in an on-disk SQLite database. We define the following
tables.

Clients: 
  user_id INTEGER: A unique id per user.
  user_name TEXT: A user's display name. Currently does not have to be unique 
    but we may enforce uniqueness in the future.
Chats: 
  chat_id INTEGER: A unique id per chat.
  chat_name TEXT: The chat's display name for group chats or NULL for private
    chats. The display names for private chats are dynamically generated by the
    server to be the name of the receiving user.
  is_private_chat BOOLEAN: Whether this chat is a private chat.
Participants:
  participant_id: A unique id per participant.
  chat_id: The id of the chat this participant is in.
  user_id: The user_id of the participant.
Messages: 
  message_id INTEGER: A unique id per message. 
  chat_id: The id of the chat this message belongs to.
  user_id: The id of the user who sent this message.
  timestamp: The timestamp when the server received this message. N.B. that 
    using timestamp to sort chat messages can lead to ordering issues, 
    particularly in the case when we have more than one server. OK for now.


Better server processes:
The server uses a separate process for each client. Ultimately, processes 
should be decoupled from clients so the server can scale to handle many more
clients. One option for this is to have a client queue which is shared across
processes. Each client is put on the queue and worker processes take clients
off the queue, process them, and place them at the end of the queue. 

Of course, there are a number of issues with this approach: 
  1. The queue could become a bottleneck if there is a lot of contention from
     many processes reading and writing at the same time. 
  2. Clients could become starved if all processes are busy handling big 
     requests. We could maybe mitigate this with some kind of async 
     programming.
  3. Since we're using processes for "multithreading", context switching 
     between clients all the time could have high overhead. (It may also make
     sense to switch to threads entierly -- the code is highly I/O bound so we
     won't suffer too much penalty from the GIL.

A related approach could be to have multiple client queues and assign subsets of
processes to each queue. While this can mitigate issues 1, issues 2 and 3 would
still pose problems.
